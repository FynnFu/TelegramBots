import inspect
import json
import os
import threading
import logging
import time
import traceback

import telebot

from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.urls import reverse
from django.db import transaction
from django.contrib.sites.models import Site
from django.shortcuts import render, redirect
from openai import OpenAI, RateLimitError
from telebot import types
from telebot.types import BotCommand, LabeledPrice
from dotenv import load_dotenv
from telegram import constants
from telegram.helpers import escape_markdown

from TelegramBots import settings
from ChatGPT.models import TelegramUsers, Promocodes, Channels, GPTModels, Prices, Tips

load_dotenv()

TOKEN = os.getenv("TOKEN_GPT")

URL = settings.URL

WEBHOOK_URL = URL + "chatgpt/webhook/"

Bot = telebot.TeleBot(TOKEN)

commands = [
    BotCommand('start', 'üîÑ –ó–∞–ø—É—Å—Ç–∏—Ç—å/–ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞'),
    BotCommand('ref', "üì® –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ"),
    BotCommand('promocode', "üîë –í–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–æ–∫–æ–¥"),
    BotCommand('start_new_dialog', "‚ûï –ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥"),
]

Bot.set_my_commands(commands)

client = OpenAI(api_key=settings.API_KEY)

logger = logging.getLogger('django')


class Console:
    botThread = None

    @staticmethod
    def set_webhook():
        Bot.remove_webhook()
        time.sleep(5)
        Bot.set_webhook(url=WEBHOOK_URL)

    @staticmethod
    @csrf_exempt
    def webhook(request):
        if request.method == "POST":
            json_string = request.body.decode("utf-8")
            update = telebot.types.Update.de_json(json_string)
            Bot.process_new_updates([update])
            return JsonResponse({"status": "ok"})

    @staticmethod
    def status():
        is_bot = Bot.get_me().is_bot
        name = Bot.get_me().username

        text = f"Bot({name}) is bot: {is_bot}\n"
        return text

    @staticmethod
    def run(request):
        if Console.botThread is not None:
            if not Console.botThread.is_alive():
                Console.botThread = threading.Thread(target=Console.set_webhook())
                Console.botThread.start()
        else:
            Console.botThread = threading.Thread(target=Console.set_webhook())
            Console.botThread.start()
        print(f'Bot is now running in a separate thread.')
        return redirect('ChatGPT:console')

    @staticmethod
    def stop(request):
        if Console.botThread is not None:
            if Console.botThread.is_alive():
                Bot.delete_webhook()
        print(f'Bot is now stopping in a separate thread.')
        return redirect('ChatGPT:console')

    @staticmethod
    def render(request):
        name = Bot.get_my_name().name
        context = {
            'bot_name': name
        }
        return render(request, 'chatgpt/console.html', context)

    @staticmethod
    def error(request):
        return render(request, 'chatgpt/error.html')


def requires_subscription(func):
    @Bot.callback_query_handler(func=lambda call: call.data == 'check_subscribe')
    @transaction.atomic
    def wrapper(message, *args, **kwargs):
        try:
            if not TelegramUsers.objects.filter(id=message.from_user.id).exists():
                user = TelegramUsers(
                    id=message.from_user.id,
                    username=message.from_user.username,
                    first_name=message.from_user.first_name,
                    last_name=message.from_user.last_name,
                    blocked=False,
                    is_staff=False,
                    RPD=5,
                    RPD_BONUS=0,
                    IPD=1,
                    referrer=None,
                    referrals=0,
                    messages='[]',
                    model=GPTModels.objects.get(name="GPT-4")
                )
                user.save()

            user = TelegramUsers.objects.get(id=message.from_user.id)
            if user.is_blocked():
                Bot.send_message(message.from_user.id,
                                 "‚ÄºÔ∏è–í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã ‚ÄºÔ∏è\n"
                                 "–ó–∞ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏ –ø–∏—Å–∞—Ç—å @FynnFu")
                return None

            reply_message_id = None
            if type(message) == types.Message:
                reply_message_id = message.message_id
            elif type(message) == types.CallbackQuery:
                reply_message_id = message.message.message_id

            validation = True
            channels = Channels.objects.all()
            markup = types.InlineKeyboardMarkup()

            for channel in channels:
                chat_member = Bot.get_chat_member(channel.id, message.from_user.id)
                if not (chat_member.status == "member" or
                        chat_member.status == "administrator" or
                        chat_member.status == "creator"):
                    validation = False
                    markup.add(
                        types.InlineKeyboardButton(text=channel.name, url=channel.url)
                    )

            markup.add(
                types.InlineKeyboardButton(text="‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è", callback_data='check_subscribe')
            )

            if validation:
                return func(message, *args, **kwargs)
            else:
                if type(message) == types.CallbackQuery:
                    if message.data == 'check_subscribe':
                        Bot.answer_callback_query(callback_query_id=message.id,
                                                  show_alert=True,
                                                  text='–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã!')
                    else:
                        Bot.send_message(message.from_user.id,
                                         "–î–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º, –≤–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª.\n"
                                         "–ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏, –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–Ω–æ–ø–∫—É.",
                                         reply_markup=markup,
                                         reply_to_message_id=reply_message_id)
                else:
                    Bot.send_message(message.from_user.id,
                                     "–î–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º, –≤–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª.\n"
                                     "–ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏, –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–Ω–æ–ø–∫—É.",
                                     reply_markup=markup,
                                     reply_to_message_id=reply_message_id)
                return None
        except Exception as ex:
            send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())

    return wrapper


@Bot.message_handler(commands=['start'])
@transaction.atomic
@requires_subscription
def start(message):
    try:
        Bot.send_message(message.from_user.id,
                         "–ü—Ä–∏–≤–µ—Ç! ü§ñ –Ø - ChatGPT, —Ç–≤–æ–π —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫ –æ—Ç OpenAI! üåê \n"
                         "\n"
                         "–ú–æ–∂–µ—à—å –∑–∞–¥–∞–≤–∞—Ç—å –ª—é–±—ã–µ –≤–æ–ø—Ä–æ—Å—ã, –æ—Ç –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏ –¥–æ —Ç–≤–æ—Ä—á–µ—Å—Ç–≤–∞. üí°\n"
                         "\n"
                         "–õ—é–±–∏—à—å –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ? –Ø —Ç–æ–∂–µ! üñ•Ô∏è –ì–æ—Ç–æ–≤ –ø–æ–º–æ—á—å —Å –∫–æ–¥–æ–º. \n"
                         "\n"
                         "–ü–∏—à–∏ —Å–≤–æ–∏ –∏–¥–µ–∏, –∏ —è —Å–æ–∑–¥–∞–º —Ç–µ–∫—Å—Ç –¥–ª—è –Ω–∏—Ö! ‚ú®\n"
                         "\n"
                         "–û—Å–≤–µ–∂–∏ –≤ –ø–∞–º—è—Ç–∏ –º–∞—Ç–µ—Ä–∏–∞–ª—ã —à–∫–æ–ª—ã –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –ø–æ–±–æ–ª—Ç–∞–µ–º. üó£Ô∏è\n"
                         "\n"
                         "–ñ–¥—É —Ç–≤–æ–∏ –≤–æ–ø—Ä–æ—Å—ã –∏ –∏–¥–µ–∏! üöÄ",
                         reply_markup=menu(message))
        if type(message) == types.Message:
            start_param = message.text[len('/start '):]
            if start_param != '' and '/start ' in message.text:
                ref(message)
        elif type(message) == types.CallbackQuery:
            start_param = message.message.reply_to_message.text[len('/start '):]
            if start_param != '' and '/start ' in message.message.reply_to_message.text:
                ref(message.message.reply_to_message)
    except Exception as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


@Bot.message_handler(commands=['ref'])
@transaction.atomic
@requires_subscription
def ref(message):
    try:
        user = TelegramUsers.objects.get(id=message.from_user.id)
        if user.referrer is None:
            referrer_id = message.text.split()[1:]
            if len(referrer_id) == 0:
                Bot.send_message(message.from_user.id,
                                 "üì® –í–≤–µ–¥–∏—Ç–µ –∞–≤—Ç–æ—Ä–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è\n"
                                 "\n"
                                 "/ref ||—Ç—É—Ç id –∞–≤—Ç–æ—Ä–∞||",
                                 reply_markup=menu(message),
                                 parse_mode='MarkdownV2')
            elif len(referrer_id) == 1 and int(referrer_id[0]) == message.from_user.id:
                Bot.send_message(message.from_user.id,
                                 "üòú –ê —Ç—ã —É–º—ë–Ω, –Ω–æ –∞–≤—Ç–æ—Ä–æ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∫—Ç–æ-—Ç–æ –¥—Ä—É–≥–æ–π",
                                 reply_markup=menu(message))
            elif len(referrer_id) == 1 and TelegramUsers.objects.filter(id=referrer_id[0]).exists():
                referrer = TelegramUsers.objects.get(id=referrer_id[0])
                user.set_referrer(referrer)
                user.add_rpd_bonus(3)

                referrer.add_rpd_bonus(3)
                referrer.add_referral()

                Bot.send_message(message.from_user.id, "üéâ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ\n"
                                                       "üéÅ –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ 3 –±–æ–Ω—É—Å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–∞\n",
                                 reply_markup=menu(message))
            else:
                Bot.send_message(message.from_user.id, "üßê –ê–≤—Ç–æ—Ä –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω", reply_markup=menu(message))
        else:
            Bot.send_message(message.from_user.id, "‚ùå –í—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ", reply_markup=menu(message))
    except Exception as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


@Bot.callback_query_handler(func=lambda call: call.data == 'profile')
@Bot.message_handler(func=lambda message: message.text == 'üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å')
@requires_subscription
def profile(message):
    try:
        user = TelegramUsers.objects.get(id=message.from_user.id)

        markup = types.InlineKeyboardMarkup()
        markup.add(
            types.InlineKeyboardButton(text="‚ú® –ö—É–ø–∏—Ç—å –∑–∞–ø—Ä–æ—Å—ã", callback_data='gpt_premium')
        )
        markup.add(
            types.InlineKeyboardButton(text="ü§ù –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –¥—Ä—É–≥–∞", callback_data='invite_friend')
        )
        markup.add(
            types.InlineKeyboardButton(text="üîë –í–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–æ–∫–æ–¥", callback_data='enter_promocode')
        )
        text = f"üë§: {user.first_name} {user.last_name} ({user.username})\n" \
               f"\n" \
               f"üí¨: –î–æ—Å—Ç—É–ø–Ω–æ –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è ChatGPT-4:\n" \
               f"    üéÅ –ë–æ–Ω—É—Å–Ω—ã—Ö: {user.RPD_BONUS}\n" \
               f"    üîÑ –ï–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö: {user.RPD}\n" \
               f"\n" \
               f"üñº: –î–æ—Å—Ç—É–ø–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è DALL-E:\n" \
               f"    üîÑ –ï–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö: {user.IPD}\n" \
               f"\n"f"–ó–∞–ø—Ä–æ—Å—ã –≤ ChatGPT –Ω—É–∂–Ω—ã, —á—Ç–æ–±—ã –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã.\n" \
               f"–ë–µ—Å–ø–ª–∞—Ç–Ω–æ –¥–∞—ë–º 5 –∑–∞–ø—Ä–æ—Å–æ–≤ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ, –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç—Å—è –≤ 00:00 –ø–æ –ê–ª–º–∞—Ç–µ.\n" \
               f"\n" \
               f"1Ô∏è‚É£ –í—ã –º–æ–∂–µ—Ç–µ –∫—É–ø–∏—Ç—å GPT –∑–∞–ø—Ä–æ—Å—ã –∏ –Ω–µ –ø–∞—Ä–∏—Ç—å—Å—è –æ –ª–∏–º–∏—Ç–∞—Ö.\n" \
               f"2Ô∏è‚É£ –í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–∏–≥–ª–∞—Å–∏—Ç—å –¥—Ä—É–≥–∞, –∏ –í—ã –∏ –æ–Ω –ø–æ–ª—É—á–∏—Ç–µ –ø–æ 3 –±–æ–Ω—É—Å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–∞.\n" \
               f"3Ô∏è‚É£ –í—ã –º–æ–∂–µ—Ç–µ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø—Ä–æ–º–æ–∫–æ–¥–æ–º, –µ—Å–ª–∏ –æ–Ω —É –≤–∞—Å –µ—Å—Ç—å.\n"

        if type(message) == types.Message:
            Bot.send_message(user.id, text=text, reply_markup=markup)
        elif type(message) == types.CallbackQuery:
            Bot.edit_message_text(
                chat_id=message.message.chat.id,
                message_id=message.message.message_id,
                text=text,
                reply_markup=markup
            )
    except Exception as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


@Bot.callback_query_handler(func=lambda call: call.data == 'invite_friend')
@requires_subscription
def invite_friend(call):
    try:
        user = TelegramUsers.objects.get(id=call.from_user.id)
        ref_command = f"/ref {user.id}"
        ref_url = f"https://t.me/free4gpt_bot?start={user.id}"
        markup = types.InlineKeyboardMarkup()
        markup.add(
            types.InlineKeyboardButton("üìù –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –∫–æ–¥–æ–º", url=f"t.me/share/url?url={ref_command}")
        )
        markup.add(
            types.InlineKeyboardButton("üìù –ü–æ–¥–µ–ª–∏—Ç—å—Å—è —Å—Å—ã–ª–∫–æ–π", url=f"t.me/share/url?url={ref_url}")
        )
        # markup.add(
        #     types.InlineKeyboardButton("‚¨ÖÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥", callback_data='profile')
        # )
        Bot.send_message(
            chat_id=call.message.chat.id,
            text=f"üë• –í—ã –ø—Ä–∏–≥–ª–∞—Å–∏–ª–∏: {user.referrals} —á–µ–ª–æ–≤–µ–∫(-–∞)\n"
                 f"–í–∞—à–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è:\n"
                 f"–ö–æ–¥:\n"
                 f"{ref_command}\n"
                 f"\n"
                 f"–°—Å—ã–ª–∫–∞:\n"
                 f"{ref_url} \n"
                 f"\n"
                 f"–î–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—É, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /start.",
            reply_markup=markup)
    except Exception as ex:
        send_error_for_admins(call, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


@Bot.message_handler(commands=['promocode'])
@Bot.callback_query_handler(func=lambda call: call.data == 'enter_promocode')
@requires_subscription
def enter_promocode(message):
    try:
        text = f"üîë –î–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –ø—Ä–æ–º–æ–∫–æ–¥–∞ –≤–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n" \
               f"\n" \
               f"/promocode ||—Ç—É—Ç –ø—Ä–æ–º–æ–∫–æ–¥||"
        markup = types.InlineKeyboardMarkup()
        markup.add(
            types.InlineKeyboardButton("‚¨ÖÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥", callback_data='profile')
        )
        if type(message) == types.Message:
            code = message.text.split()[1:]
            if len(code) == 0:
                Bot.send_message(message.from_user.id, text, reply_markup=menu(message), parse_mode='MarkdownV2')
            elif len(code) == 1 and Promocodes.objects.filter(code=code[0]).exists():
                promocode = Promocodes.objects.get(code=code[0])
                user = TelegramUsers.objects.get(id=message.from_user.id)
                user.add_rpd_bonus(promocode.NOR)

                promocode.delete()
                Bot.send_message(message.from_user.id, f"‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω", reply_markup=menu(message))
            else:
                Bot.send_message(message.from_user.id, f"‚ùå –ü—Ä–æ–º–æ–∫–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω", reply_markup=menu(message))
        elif type(message) == types.CallbackQuery:
            Bot.edit_message_text(
                chat_id=message.message.chat.id,
                message_id=message.message.message_id,
                text=text,
                reply_markup=markup,
                parse_mode='MarkdownV2'
            )
    except Exception as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


@requires_subscription
def menu(message):
    try:
        # user_id = message.from_user.id
        # user = TelegramUsers.objects.get(id=user_id)
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)

        markup.add(
            types.KeyboardButton("‚ûï –ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥"),
            types.KeyboardButton("‚ú® GPT –∑–∞–ø—Ä–æ—Å—ã")
        )
        markup.add(
            types.KeyboardButton("üöÄ Midjourney –±–æ—Ç"),
            types.KeyboardButton("ü§ñ –í—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å")
        )
        markup.add(
            types.KeyboardButton("üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å")
        )
        return markup
    except Exception as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())
        return None


@Bot.message_handler(commands=['start_new_dialog'])
@Bot.callback_query_handler(func=lambda call: call.data == 'start_new_dialog')
@Bot.message_handler(func=lambda message: message.text == '‚ûï –ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥')
@requires_subscription
def start_new_dialog(message):
    try:
        user_id = message.from_user.id
        user = TelegramUsers.objects.get(id=user_id)
        user.clear_messages()
        content = "ü§ñ –ü—Ä–∏–≤–µ—Ç! –Ø ChatGPT. –ß–µ–º —è –º–æ–≥—É —Ç–µ–±–µ –ø–æ–º–æ—á—å?"
        user.add_message("assistant", content)
        Bot.send_message(message.from_user.id, text=content, reply_markup=menu(message))

    except Exception as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


@Bot.callback_query_handler(func=lambda call: call.data == 'gpt_premium')
@Bot.message_handler(func=lambda message: message.text == '‚ú® GPT –∑–∞–ø—Ä–æ—Å—ã')
@requires_subscription
def gpt_premium(message):
    try:
        user_id = message.from_user.id
        user = TelegramUsers.objects.get(id=user_id)
        user.clear_messages()
        content = "üëá –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—Ä–æ—Å–æ–≤\n" \
                  "\n" \
                  "üîπ –ó–∞–ø—Ä–æ—Å—ã –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ —Å–≥–æ—Ä–∞—é—Ç, –º–æ–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å —Å–∫–æ–ª—å–∫–æ —É–≥–æ–¥–Ω–æ –ø–æ –≤—Ä–µ–º–µ–Ω–∏\n" \
                  "üî∏ –ó–∞–ø—Ä–æ—Å—ã –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –∫ –±–æ–Ω—É—Å–Ω—ã–º –∑–∞–ø—Ä–æ—Å–∞–º –∏ –≤—ã —Å–º–æ–∂–µ—Ç–µ –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã\n"
        markup = types.InlineKeyboardMarkup()

        prices = Prices.objects.all()

        for price in prices:
            text = f"{price.description} - {price.price} ‚ÇΩ"
            if price.in_top():
                text = "üî• " + text
            markup.add(
                types.InlineKeyboardButton(text=text,
                                           callback_data=f"price_selected:{price.price}")
            )

        Bot.send_message(message.from_user.id, text=content, reply_markup=markup)

    except Exception as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


@Bot.callback_query_handler(lambda call: call.data.startswith('price_selected:'))
def process_price_selected(call):
    try:
        price = call.data.split(':')[-1]
        price_obj = Prices.objects.get(price=price)
        tips = Tips.objects.all()
        payload = {
            "user_id": call.from_user.id,
            "value": price_obj.value
        }

        Bot.send_invoice(
            call.from_user.id,
            "GPT-4 –∑–∞–ø—Ä–æ—Å—ã",
            description=price_obj.description,
            provider_token=os.getenv("TOKEN_YOOKASSA"),
            currency="RUB",
            prices=[
                LabeledPrice(
                    label=price_obj.description,
                    amount=price_obj.price * 100
                )
            ],
            max_tip_amount=500 * 100,
            suggested_tip_amounts=[tip.amount * 100 for tip in tips],
            start_parameter="free4gpt_bot",
            provider_data=None,
            photo_url="https://static2.tgstat.ru/channels/_0/dd/dd151ce9a6bc922029428ad2b61936ad.jpg",
            photo_size=30000,
            photo_width=640,
            photo_height=640,
            need_name=False,
            need_phone_number=False,
            need_email=False,
            need_shipping_address=False,
            send_phone_number_to_provider=False,
            send_email_to_provider=False,
            is_flexible=False,
            disable_notification=False,
            protect_content=False,
            reply_to_message_id=None,
            allow_sending_without_reply=True,
            reply_markup=None,
            invoice_payload=json.dumps(payload)
        )
    except Exception as ex:
        send_error_for_admins(call, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


@Bot.pre_checkout_query_handler(func=lambda query: True)
def pre_checkout(pre_checkout_query):
    try:
        Bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)
    except Exception as ex:
        send_error_for_admins(pre_checkout_query, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


@Bot.message_handler(content_types=['successful_payment'])
def process_successful_payment(message):
    try:
        invoice_payload = message.successful_payment.invoice_payload
        payload = json.loads(invoice_payload)
        user = TelegramUsers.objects.get(id=payload['user_id'])
        user.add_rpd_bonus(int(payload['value']))
        Bot.send_message(message.from_user.id,
                         f"ü•≥ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é, –æ–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–∞.\n"
                         f"\n"
                         f"‚ú® –í–∞—à–∏ –∑–∞–ø—Ä–æ—Å—ã —É–∂–µ –Ω–∞—á–∏—Å–ª–µ–Ω—ã –í–∞–º –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç, –Ω–∞—Å–ª–∞–∂–¥–∞–π—Ç–µ—Å—å –≤—Å–µ–º–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏ GPT-4")
    except Exception as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


def generate_gpt_response(prompt, model, message):
    try:
        if model == 'gpt-4-0314':
            Bot.send_chat_action(message.from_user.id, 'typing')
            completion = client.chat.completions.create(
                model=f"{model}",
                messages=prompt
            )
            return completion.choices[0].message.content

        if model == 'gpt-3.5-turbo':
            Bot.send_chat_action(message.from_user.id, 'typing')
            completion = client.chat.completions.create(
                model=f"{model}",
                messages=prompt
            )
            return completion.choices[0].message.content

    except RateLimitError as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())
        return "‚ùóÔ∏è –°–∏—Å—Ç–µ–º–Ω–∞—è –æ—à–∏–±–∫–∞ ‚ùóÔ∏è"
    except Exception as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())
        return "‚ùóÔ∏è –°–∏—Å—Ç–µ–º–Ω–∞—è –æ—à–∏–±–∫–∞ ‚ùóÔ∏è"


@Bot.message_handler(func=lambda message: message.text == 'üöÄ Midjourney –±–æ—Ç')
@requires_subscription
def midjourney(message):
    try:
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton(text="üöÄ Midjourney", url="https://t.me/Midjorai_bot"))
        Bot.send_message(message.from_user.id,
                         "–î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –±–æ—Ç–∞ Midjourney\n"
                         "–î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–ª–∏–∫–Ω—É—Ç—å –Ω–∞ –∫–Ω–æ–ø–∫—É –ø–æ–¥ —ç—Ç–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.",
                         reply_markup=markup)
    except Exception as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


@Bot.message_handler(func=lambda message: message.text == 'ü§ñ –í—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å')
@requires_subscription
def choose_model(message):
    try:
        user_id = message.from_user.id
        markup = types.InlineKeyboardMarkup()
        models = GPTModels.objects.all()
        user = TelegramUsers.objects.get(id=user_id)
        for model in models:
            model_name = model.name
            if model == user.model:
                model_name = f"‚úÖ {model.name} ‚úÖ"

            markup.add(
                types.InlineKeyboardButton(
                    text=f"{model_name}",
                    callback_data=model.slug
                )
            )
        if type(message) == types.Message:
            Bot.send_message(message.from_user.id,
                             "–û—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏ –∑–∞–≤–∏—Å–∏—Ç —Å–∫–æ—Ä–æ—Å—Ç—å –∏ –∫–∞—á–µ—Å—Ç–≤–æ –æ—Ç–≤–µ—Ç–∞."
                             "\n"
                             "–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω—É –º–æ–¥–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞:\n",
                             reply_markup=markup)
        return markup
    except Exception as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


@Bot.callback_query_handler(func=lambda call: True)
def set_user_model(call):
    try:
        models = GPTModels.objects.all()
        user_id = call.from_user.id
        user = TelegramUsers.objects.get(id=user_id)
        for model in models:
            if call.data == model.slug:
                if user.model != model:
                    user.set_model(model)
                    Bot.edit_message_reply_markup(call.from_user.id, call.message.message_id,
                                                  reply_markup=choose_model(call))
    except Exception as ex:
        send_error_for_admins(call, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


def send_error_for_admins(message, ex, method_name, error_details):
    user_id = None
    if message is not None:
        Bot.send_message(message.from_user.id,
                         "‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞, —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –º–æ–¥–µ—Ä–∞—Ü–∏–∏.\n"
                         "–ü–æ–¥–æ–∂–¥–∏—Ç–µ –ø–∞—Ä—É –º–∏–Ω—É—Ç –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É.")
        user_id = message.from_user.id
    admins = TelegramUsers.objects.filter(is_staff=True)
    text = "‚ùóÔ∏è –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç —Å–∏—Å—Ç–µ–º—ã ‚ùóÔ∏è\n" \
           f"User ID: {user_id}\n" \
           f"Method: {method_name}\n" \
           f"Error type: {type(ex).__name__}\n" \
           f"Error message: {str(ex)}\n"
    logger.error(text)
    markup = types.InlineKeyboardMarkup()
    host = Site.objects.get_current()
    markup.add(
        types.InlineKeyboardButton(text="–°—Ç—Ä–∞–Ω–∏—Ü–∞ —Å –æ—à–∏–±–∫–æ–π", url=f"{host}{reverse(f'ChatGPT:error')}")
    )
    text_to_error_html(error_details)
    for admin in admins:
        Bot.send_message(admin.id, text, reply_markup=markup)
    print(text)


@Bot.message_handler(func=lambda message: True)
@requires_subscription
def handle_messages(message):
    try:
        user_id = message.from_user.id
        user = TelegramUsers.objects.get(id=user_id)

        if message.text == "‚ûï –ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥" or message.text == "/start_new_dialog" \
                or message.text == "‚ú® GPT –∑–∞–ø—Ä–æ—Å—ã" \
                or message.text == "üöÄ Midjourney –±–æ—Ç" \
                or message.text == "ü§ñ –í—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å" \
                or message.text == "üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å" \
                or message.text == "/ref" \
                or message.text == "/promocode":
            return
        else:
            if user.get_rpd_bonus() > 0 or user.get_rpd() > 0:
                thinking_message = Bot.send_message(message.from_user.id,
                                                    "üß† –î—É–º–∞—é –Ω–∞–¥ –æ—Ç–≤–µ—Ç–æ–º...",
                                                    reply_to_message_id=message.message_id)

                user.add_message("user", message.text)

                gpt_response = generate_gpt_response(user.get_messages(),
                                                     user.get_model().slug,
                                                     message)

                # characters = {'_', '*', '[', ']', '(', ')', '~', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!'}
                #
                # for character in characters:
                #     gpt_response = gpt_response.replace(character, f'\\{character}')

                gpt_response = escape_markdown(gpt_response, version=2, entity_type="code")

                if user.get_rpd_bonus() > 0:
                    user.remove_rpd_bonus(1)
                elif user.get_rpd() > 0:
                    user.remove_rpd(1)

                if len(gpt_response) > 4095:
                    for x in range(0, len(gpt_response), 4095):
                        Bot.edit_message_text(chat_id=message.from_user.id,
                                              message_id=thinking_message.message_id,
                                              text=gpt_response[x:x + 4095],)
                                              # parse_mode=constants.ParseMode.MARKDOWN_V2)
                else:
                    Bot.edit_message_text(chat_id=message.from_user.id,
                                          message_id=thinking_message.message_id,
                                          text=gpt_response,)
                                          # parse_mode=constants.ParseMode.MARKDOWN_V2)

                user.add_message("assistant", gpt_response)

            else:
                markup = types.InlineKeyboardMarkup()
                markup.add(
                    types.InlineKeyboardButton(text="‚ú® –ö—É–ø–∏—Ç—å –∑–∞–ø—Ä–æ—Å—ã", callback_data='gpt_premium')
                )
                markup.add(
                    types.InlineKeyboardButton(text="ü§ù –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –¥—Ä—É–≥–∞", callback_data='invite_friend')
                )
                Bot.send_message(message.from_user.id,
                                 "–£ –í–∞—Å –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –∑–∞–ø—Ä–æ—Å—ã üò¢\n"
                                 "\n"
                                 "–ù–µ –±–µ–¥–∞, –≤—ã –º–æ–∂–µ—Ç–µ –∫—É–ø–∏—Ç—å –∏—Ö –∏–ª–∏ –ø—Ä–∏–≥–ª–∞—Å–∏—Ç—å –¥—Ä—É–≥–∞ –∏ –ø–æ–ª—É—á–∏—Ç—å –±–æ–Ω—É—Å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã",
                                 reply_markup=markup)

    except Exception as ex:
        send_error_for_admins(message, ex, inspect.currentframe().f_code.co_name, traceback.format_exc())


def text_to_error_html(error_details):
    try:
        app_templates_directory = os.path.join(settings.BASE_DIR, "ChatGPT", 'templates')
        with open(app_templates_directory + "/chatgpt/error.html",
                  'w', encoding='utf-8') as file:
            file.write(str(error_details))
    except Exception as ex:
        logger.error(ex)
